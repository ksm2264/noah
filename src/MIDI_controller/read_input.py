from mido import MidiFile, MidiTrack, Message\nimport time\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef convert_to_notes():\n    """\n    This function reads the input from the MIDI keyboard and converts it into \n    playable notes, which can be used for the rhythm game.\n    """\n    with MidiFile(\'input.mid\') as mid:\n        for i, track in enumerate(mid.tracks):\n            logger.info(\'Track {}: {}\'.format(i, track.name))\n            for msg in track:\n                if msg.type == \'note_on\':\n                    logger.info(f"Noted {msg.note} with velocity {msg.velocity}")\n                    time.sleep(0.1)\n                elif msg.type == \'note_off\':\n                    logger.info(f"Note {msg.note} stopped")\n\ndef check_timing(on_screen_notes, played_notes):\n    """\n    This function checks the timing of the played notes against the on-screen notes.\n    """\n    timing_accuracy = 0\n    for i in range(len(on_screen_notes)):\n        if on_screen_notes[i].timing == played_notes[i].timing and on_screen_notes[i].note == played_notes[i].note:\n            timing_accuracy += 1\n    accuracy = (timing_accuracy/len(on_screen_notes))*100\n    logger.info(f"Timing accuracy: {accuracy:.2f}%")\n    return accuracy\n\n\ndef score_user(timing_accuracy):\n    """\n    This function calculates and updates the user\'s score based on the accuracy of the timing.\n    """\n    score = 0\n    if timing_accuracy >= 90:\n        score = 5\n    elif timing_accuracy >= 70:\n        score = 3\n    elif timing_accuracy >= 50:\n        score = 1\n    else:\n        score = 0\n    logger.info(f"Score updated: {score}")\n    return score\n', '